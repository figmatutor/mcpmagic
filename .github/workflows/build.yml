name: Build Desktop (MAS + MSIX)

on:
  workflow_dispatch:
    inputs:
      version:
        description: Version to build (e.g. 2.0.9.20)
        required: true
        type: string

concurrency:
  group: build-desktop
  cancel-in-progress: false

jobs:
  resolve-version:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      full_version: ${{ steps.resolve.outputs.full_version }}
      mas_version: ${{ steps.resolve.outputs.mas_version }}
      mas_build_number: ${{ steps.resolve.outputs.mas_build_number }}
      windows_version: ${{ steps.resolve.outputs.windows_version }}
    steps:
      - name: Resolve version input
        id: resolve
        shell: bash
        run: |
          set -euo pipefail
          VERSION="${{ github.event.inputs.version || '' }}"
          VERSION="$(echo "$VERSION" | tr -d '[:space:]')"
          if [ -z "$VERSION" ]; then
            echo "::error::workflow_dispatch input 'version' is required (e.g. 2.0.9.20)"
            exit 1
          fi
          if [[ ! "$VERSION" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            echo "::error::Invalid version format: $VERSION"
            echo "::error::Expected 4-part numeric version (e.g. 2.0.9.20)"
            exit 1
          fi

          MAS_VERSION="${BASH_REMATCH[1]}.${BASH_REMATCH[2]}.${BASH_REMATCH[3]}"
          MAS_BUILD_NUMBER="${BASH_REMATCH[4]}"
          WINDOWS_VERSION="$VERSION"

          echo "full_version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "mas_version=$MAS_VERSION" >> "$GITHUB_OUTPUT"
          echo "mas_build_number=$MAS_BUILD_NUMBER" >> "$GITHUB_OUTPUT"
          echo "windows_version=$WINDOWS_VERSION" >> "$GITHUB_OUTPUT"

          echo "Resolved full version: $VERSION"
          echo "MAS version/build: $MAS_VERSION ($MAS_BUILD_NUMBER)"
          echo "Windows version: $WINDOWS_VERSION"

  build-mas:
    needs: resolve-version
    runs-on: macos-latest
    timeout-minutes: 120
    env:
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      SIGNING_IDENTITY_APPSTORE: ${{ secrets.SIGNING_IDENTITY_APPSTORE }}
      INSTALLER_IDENTITY: ${{ secrets.INSTALLER_IDENTITY }}
      SIGNING_CERTIFICATE_BASE64: ${{ secrets.SIGNING_CERTIFICATE_BASE64 }}
      SIGNING_CERTIFICATE_PASSWORD: ${{ secrets.SIGNING_CERTIFICATE_PASSWORD }}
      INSTALLER_CERTIFICATE_BASE64: ${{ secrets.INSTALLER_CERTIFICATE_BASE64 }}
      PROVISIONING_PROFILE_BASE64: ${{ secrets.PROVISIONING_PROFILE_BASE64 }}
      PROVISIONING_PROFILE: ${{ secrets.PROVISIONING_PROFILE }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Validate app runtime secrets
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${{ secrets.FIGMA_CLIENT_ID }}" ] || [ -z "${{ secrets.FIGMA_CLIENT_SECRET }}" ]; then
            echo "::error::Missing FIGMA_CLIENT_ID or FIGMA_CLIENT_SECRET"
            exit 1
          fi
          if [ -z "${{ secrets.GOOGLE_ANALYTICS_ID }}" ] || [ -z "${{ secrets.GOOGLE_ANALYTICS_API_SECRET }}" ]; then
            echo "::error::Missing GOOGLE_ANALYTICS_ID or GOOGLE_ANALYTICS_API_SECRET"
            exit 1
          fi
          echo "Runtime secrets for OAuth/Analytics are configured"

      - name: Validate MAS secrets
        run: |
          set -euo pipefail
          required=(
            APPLE_TEAM_ID
            SIGNING_IDENTITY_APPSTORE
            INSTALLER_IDENTITY
            SIGNING_CERTIFICATE_BASE64
            SIGNING_CERTIFICATE_PASSWORD
            INSTALLER_CERTIFICATE_BASE64
          )
          for key in "${required[@]}"; do
            if [ -z "${!key:-}" ]; then
              echo "::error::Missing required secret: ${key}"
              exit 1
            fi
          done
          if [ -z "${PROVISIONING_PROFILE_BASE64:-}" ] && [ -z "${PROVISIONING_PROFILE:-}" ]; then
            echo "::error::Missing provisioning profile secret: set PROVISIONING_PROFILE_BASE64 or PROVISIONING_PROFILE"
            exit 1
          fi

      - name: Prepare signing
        run: |
          set -euo pipefail

          # Decode certificates and provisioning profile
          echo "$SIGNING_CERTIFICATE_BASE64" | base64 --decode > /tmp/signing-cert.p12
          echo "$INSTALLER_CERTIFICATE_BASE64" | base64 --decode > /tmp/installer-cert.p12
          if [ -n "${PROVISIONING_PROFILE_BASE64:-}" ]; then
            echo "$PROVISIONING_PROFILE_BASE64" | base64 --decode > /tmp/profile.provisionprofile
          elif [ -n "${PROVISIONING_PROFILE:-}" ] && [ -f "${PROVISIONING_PROFILE}" ]; then
            cp "${PROVISIONING_PROFILE}" /tmp/profile.provisionprofile
          elif [ -n "${PROVISIONING_PROFILE:-}" ]; then
            # Fallback: allow raw base64 payload in PROVISIONING_PROFILE
            echo "$PROVISIONING_PROFILE" | base64 --decode > /tmp/profile.provisionprofile
          else
            echo "::error::No provisioning profile value provided"
            exit 1
          fi

          # Create keychain
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security set-keychain-settings -lut 21600 build.keychain

          # Import certificates (allow both codesign AND productbuild)
          security import /tmp/signing-cert.p12 -k build.keychain \
            -P "$SIGNING_CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/productbuild
          security import /tmp/installer-cert.p12 -k build.keychain \
            -P "$SIGNING_CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/productbuild

          # Allow codesign/productbuild to access keychain without prompting
          security list-keychains -d user -s build.keychain
          security set-key-partition-list -S apple-tool:,apple: \
            -s -k "$KEYCHAIN_PASSWORD" build.keychain

          # Verify certificates
          security find-identity -v -p codesigning build.keychain

          # Install provisioning profile
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          cp /tmp/profile.provisionprofile ~/Library/MobileDevice/Provisioning\ Profiles/

          # Cleanup temp files
          rm -f /tmp/signing-cert.p12 /tmp/installer-cert.p12

      - name: Build MAS
        env:
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          FIGMA_CLIENT_ID: ${{ secrets.FIGMA_CLIENT_ID }}
          FIGMA_CLIENT_SECRET: ${{ secrets.FIGMA_CLIENT_SECRET }}
          GOOGLE_ANALYTICS_ID: ${{ secrets.GOOGLE_ANALYTICS_ID }}
          GOOGLE_ANALYTICS_API_SECRET: ${{ secrets.GOOGLE_ANALYTICS_API_SECRET }}
          DISTRIBUTION_CHANNEL: app_store
        run: |
          set -euo pipefail
          ROOT="$GITHUB_WORKSPACE"
          TMP_DIR="${TMPDIR:-/tmp}/mcpmagic-talktofigma-desktop"
          export TMP_DIR

          rm -rf "$TMP_DIR"
          git clone --depth=1 https://github.com/grab/TalkToFigmaDesktop "$TMP_DIR"

          node -e "const fs=require('fs');const path=require('path');const meta=require('./desktop/branding/metadata.json');const pkgPath=path.join(process.env.TMP_DIR,'package.json');const p=JSON.parse(fs.readFileSync(pkgPath,'utf8'));p.name=meta.appName.toLowerCase().replace(/[^a-z0-9.-]/g,'-');p.productName=meta.productName;p.description=meta.description;fs.writeFileSync(pkgPath,JSON.stringify(p,null,2));"

          node -e "
            const fs = require('fs');
            const path = require('path');
            const meta = require('./desktop/branding/metadata.json');
            const forgePath = path.join(process.env.TMP_DIR, 'forge.config.ts');
            let c = fs.readFileSync(forgePath, 'utf8');

            // Replace appBundleId (supports both single and double quotes)
            const bundleIdBefore = c.match(/appBundleId:\s*['\"]([^'\"]*)['\"]/) || [];
            c = c.replace(/appBundleId:\s*['\"'][^'\"]*['\"']/, \`appBundleId: '\${meta.bundleId}'\`);
            const bundleIdAfter = c.match(/appBundleId:\s*['\"]([^'\"]*)['\"]/) || [];

            // Replace name
            const nameBefore = c.match(/name:\s*['\"]([^'\"]*)['\"]/) || [];
            c = c.replace(/name:\s*['\"'][^'\"]*['\"']/, \`name: '\${meta.productName}'\`);
            const nameAfter = c.match(/name:\s*['\"]([^'\"]*)['\"]/) || [];

            // Replace executableName
            const execName = meta.productName.toLowerCase().replace(/[^a-z0-9.-]/g, '-');
            const execBefore = c.match(/executableName:\s*['\"]([^'\"]*)['\"]/) || [];
            c = c.replace(/executableName:\s*['\"'][^'\"]*['\"']/, \`executableName: '\${execName}'\`);
            const execAfter = c.match(/executableName:\s*['\"]([^'\"]*)['\"]/) || [];

            fs.writeFileSync(forgePath, c);

            // Verify replacements
            console.log('Bundle ID: ' + bundleIdBefore[1] + ' → ' + bundleIdAfter[1]);
            console.log('Name: ' + nameBefore[1] + ' → ' + nameAfter[1]);
            console.log('Executable: ' + execBefore[1] + ' → ' + execAfter[1]);

            if (bundleIdAfter[1] !== meta.bundleId) {
              console.error('ERROR: Bundle ID replacement failed!');
              console.error('Expected: ' + meta.bundleId);
              console.error('Got: ' + bundleIdAfter[1]);
              process.exit(1);
            }
          "
          node -e "
            const fs = require('fs');
            const path = require('path');
            const meta = require('./desktop/branding/metadata.json');
            const projectRoot = process.env.TMP_DIR;

            const productName = meta.productName || meta.appName || 'MCP Magic';
            const terminalProductName = meta.terminalProductName || productName.toUpperCase();
            const deepLinkScheme = (meta.deepLinkScheme || meta.appName || productName)
              .toLowerCase()
              .replace(/[^a-z0-9]/g, '');

            const replaceInFile = (relPath, replacements) => {
              const filePath = path.join(projectRoot, relPath);
              if (!fs.existsSync(filePath)) return;
              let content = fs.readFileSync(filePath, 'utf8');
              let changed = false;
              for (const [from, to] of replacements) {
                if (content.includes(from)) {
                  content = content.split(from).join(to);
                  changed = true;
                }
              }
              if (changed) fs.writeFileSync(filePath, content);
            };

            replaceInFile('index.html', [
              ['<title>Talk To Figma</title>', '<title>' + productName + '</title>'],
            ]);

            replaceInFile('src/App.tsx', [
              ['TalkToFigma Desktop v2.0.0', terminalProductName + ' Desktop v2.0.0'],
              ['talktofigma://', deepLinkScheme + '://'],
            ]);

            replaceInFile('src/components/app-sidebar.tsx', [
              ['alt=\"TalkToFigma\"', 'alt=\"' + productName + '\"'],
              ['>TalkToFigma</span>', '>' + productName + '</span>'],
            ]);

            replaceInFile('src/pages/Settings.tsx', [
              ['Configure TalkToFigma Desktop with your preferred MCP client', 'Configure ' + productName + ' with your preferred MCP client'],
            ]);

            replaceInFile('src/pages/Help.tsx', [
              ['Learn how to use TalkToFigma Desktop with our interactive tutorial', 'Learn how to use ' + productName + ' with our interactive tutorial'],
              ['Follow our step-by-step tutorial to get started with TalkToFigma Desktop.', 'Follow our step-by-step tutorial to get started with ' + productName + '.'],
            ]);
          "
          mkdir -p "$TMP_DIR/public"
          cp "$ROOT/desktop/branding/icon.icns" "$TMP_DIR/public/icon.icns"
          cp "$ROOT/desktop/branding/icon.ico" "$TMP_DIR/public/icon.ico"
          cp "$ROOT/desktop/branding/icon.png" "$TMP_DIR/public/icon.png"
          cp "$ROOT/desktop/branding/trayTemplate.png" "$TMP_DIR/public/trayTemplate.png"
          cp "$ROOT/desktop/branding/trayTemplate_active.png" "$TMP_DIR/public/trayTemplate_active.png"
          cp "$ROOT/desktop/branding/tray_dark.png" "$TMP_DIR/public/tray_dark.png"
          cp "$ROOT/desktop/branding/tray_dark_active.png" "$TMP_DIR/public/tray_dark_active.png"
          if [ -d "$ROOT/desktop/branding/icon.iconset" ]; then
            cp -R "$ROOT/desktop/branding/icon.iconset" "$TMP_DIR/public/"
          fi

          cd "$TMP_DIR"
          npm ci

          FULL_VERSION="${{ needs.resolve-version.outputs.full_version }}"
          VERSION="${{ needs.resolve-version.outputs.mas_version }}"
          BUILD_VERSION="${{ needs.resolve-version.outputs.mas_build_number }}"

          # Inject appVersion (CFBundleShortVersionString) and buildVersion (CFBundleVersion)
          node -e "
            const fs = require('fs');
            let c = fs.readFileSync('forge.config.ts', 'utf8');
            if (/appVersion:\s*'[^']*'/.test(c)) {
              c = c.replace(/appVersion:\s*'[^']*'/, \"appVersion: '${VERSION}'\");
            } else {
              c = c.replace(/packagerConfig:\s*{/, \"packagerConfig: {\\n    appVersion: '${VERSION}',\");
            }
            if (/buildVersion:\s*'[^']*'/.test(c)) {
              c = c.replace(/buildVersion:\s*'[^']*'/, \"buildVersion: '${BUILD_VERSION}'\");
            } else {
              c = c.replace(/packagerConfig:\s*{/, \"packagerConfig: {\\n    buildVersion: '${BUILD_VERSION}',\");
            }
            fs.writeFileSync('forge.config.ts', c);
          "

          export PLATFORM=mas
          export PROVISIONING_PROFILE=/tmp/profile.provisionprofile
          export CI=1
          export DEBUG=electron-osx-sign*,electron-packager,electron-forge:*
          mkdir -p "$ROOT/artifacts"

          npm run make -- --targets=pkg --platform=mas --arch=universal --verbose > "$ROOT/artifacts/mas-make.log" 2>&1 &
          BUILD_PID=$!
          START_TS=$(date +%s)
          MAX_SECONDS=$((40 * 60))

          while kill -0 "$BUILD_PID" 2>/dev/null; do
            sleep 60
            NOW_TS=$(date +%s)
            ELAPSED=$((NOW_TS - START_TS))
            echo "::notice::Build MAS still running (${ELAPSED}s elapsed) at $(date -u +%FT%TZ)"
            if [ "$ELAPSED" -ge "$MAX_SECONDS" ]; then
              echo "::error::Build MAS exceeded ${MAX_SECONDS}s watchdog timeout; terminating process"
              kill -TERM "$BUILD_PID" || true
              sleep 10
              kill -KILL "$BUILD_PID" || true
              wait "$BUILD_PID" || true
              echo "----- Last 300 lines of mas-make.log -----"
              tail -n 300 "$ROOT/artifacts/mas-make.log" || true
              exit 1
            fi
          done

          wait "$BUILD_PID"
          cat "$ROOT/artifacts/mas-make.log"

          if ! find "$TMP_DIR/out/make" -name "*-universal.pkg" -print -quit | grep -q .; then
            echo "::error::Universal MAS pkg was not produced (expected *-universal.pkg)"
            exit 1
          fi

          echo "$FULL_VERSION" > "$ROOT/artifacts/release_version.txt"
          echo "$BUILD_VERSION" > "$ROOT/artifacts/build_version.txt"
          if [ -d "$TMP_DIR/out" ]; then
            cp -R "$TMP_DIR/out"/* "$ROOT/artifacts/"
          fi

          rm -rf "$TMP_DIR"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: mas-artifacts
          path: artifacts/**

      - name: Extract version
        id: version
        run: |
          echo "version=$(cat artifacts/release_version.txt | tr -d '\n')" >> $GITHUB_OUTPUT

  upload-mas:
    needs: build-mas
    if: ${{ needs.build-mas.result == 'success' }}
    runs-on: macos-latest
    timeout-minutes: 30
    env:
      APPLE_ID: ${{ secrets.APPLE_ID }}
      APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
    steps:
      - name: Download MAS artifacts
        uses: actions/download-artifact@v4
        with:
          name: mas-artifacts
          path: artifacts

      - name: Upload to App Store Connect
        run: |
          set -euo pipefail
          PKG_FILE="$(find artifacts -name '*-universal.pkg' -print -quit)"
          if [ -z "$PKG_FILE" ]; then
            PKG_FILE="$(find artifacts -name '*.pkg' -print -quit)"
          fi
          if [ -z "$PKG_FILE" ]; then
            echo "::error::No .pkg file found for App Store upload"
            exit 1
          fi
          echo "Uploading $PKG_FILE to App Store Connect..."
          MAX_RETRIES=3
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i of $MAX_RETRIES..."
            if xcrun altool --upload-app \
              --file "$PKG_FILE" \
              --type macos \
              --username "$APPLE_ID" \
              --password "$APPLE_PASSWORD" \
              --team-id "$APPLE_TEAM_ID"; then
              echo "Upload to App Store Connect completed successfully!"
              exit 0
            fi
            if [ "$i" -lt "$MAX_RETRIES" ]; then
              WAIT=$((60 * i))
              echo "::warning::Upload failed (attempt $i). Retrying in ${WAIT}s..."
              sleep "$WAIT"
            fi
          done
          echo "::error::Upload failed after $MAX_RETRIES attempts"
          exit 1

  build-msix:
    needs: resolve-version
    runs-on: windows-latest
    timeout-minutes: 30
    env:
      MSIX_IDENTITY_NAME: ${{ secrets.MSIX_IDENTITY_NAME }}
      MSIX_PUBLISHER: ${{ secrets.MSIX_PUBLISHER }}
      MSIX_PUBLISHER_DISPLAY_NAME: ${{ secrets.MSIX_PUBLISHER_DISPLAY_NAME }}
      MSIX_PACKAGE_NAME: ${{ secrets.MSIX_PACKAGE_NAME }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Validate app runtime secrets
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${{ secrets.FIGMA_CLIENT_ID }}" ] || [ -z "${{ secrets.FIGMA_CLIENT_SECRET }}" ]; then
            echo "::error::Missing FIGMA_CLIENT_ID or FIGMA_CLIENT_SECRET"
            exit 1
          fi
          if [ -z "${{ secrets.GOOGLE_ANALYTICS_ID }}" ] || [ -z "${{ secrets.GOOGLE_ANALYTICS_API_SECRET }}" ]; then
            echo "::error::Missing GOOGLE_ANALYTICS_ID or GOOGLE_ANALYTICS_API_SECRET"
            exit 1
          fi
          echo "Runtime secrets for OAuth/Analytics are configured"

      - name: Validate MSIX secrets
        shell: bash
        run: |
          set -euo pipefail
          required=(
            MSIX_IDENTITY_NAME
            MSIX_PUBLISHER
            MSIX_PUBLISHER_DISPLAY_NAME
            MSIX_PACKAGE_NAME
          )
          for key in "${required[@]}"; do
            if [ -z "${!key:-}" ]; then
              echo "::error::Missing required secret: ${key}"
              exit 1
            fi
          done

      - name: Validate MSIX identity format
        shell: bash
        run: |
          set -euo pipefail

          identity="${MSIX_IDENTITY_NAME}"
          identity_len=${#identity}
          if [ "$identity_len" -lt 3 ] || [ "$identity_len" -gt 50 ]; then
            echo "::error::MSIX_IDENTITY_NAME must be between 3 and 50 characters (got ${identity_len})"
            exit 1
          fi
          if [[ ! "$identity" =~ ^[A-Za-z0-9][A-Za-z0-9.-]*[A-Za-z0-9]$ ]]; then
            echo "::error::MSIX_IDENTITY_NAME has invalid format: ${identity}"
            echo "::error::Use only letters, numbers, '.' and '-', and do not end with '.' or '-'"
            exit 1
          fi

          publisher="${MSIX_PUBLISHER}"
          if [[ ! "$publisher" =~ (^|,)CN=.+ ]]; then
            echo "::error::MSIX_PUBLISHER must be a Distinguished Name containing CN=..."
            exit 1
          fi

      - name: Build MSIX
        shell: bash
        env:
          FIGMA_CLIENT_ID: ${{ secrets.FIGMA_CLIENT_ID }}
          FIGMA_CLIENT_SECRET: ${{ secrets.FIGMA_CLIENT_SECRET }}
          GOOGLE_ANALYTICS_ID: ${{ secrets.GOOGLE_ANALYTICS_ID }}
          GOOGLE_ANALYTICS_API_SECRET: ${{ secrets.GOOGLE_ANALYTICS_API_SECRET }}
          DISTRIBUTION_CHANNEL: direct
        run: |
          set -euo pipefail
          ROOT="$GITHUB_WORKSPACE"
          RAW_TMP_DIR="${RUNNER_TEMP:-${TMPDIR:-/tmp}}/mcpmagic-talktofigma-desktop"
          if command -v cygpath >/dev/null 2>&1; then
            TMP_DIR="$(cygpath -u "$RAW_TMP_DIR" 2>/dev/null || echo "$RAW_TMP_DIR")"
          else
            TMP_DIR="$RAW_TMP_DIR"
          fi
          export TMP_DIR

          rm -rf "$TMP_DIR"
          git clone --depth=1 https://github.com/grab/TalkToFigmaDesktop "$TMP_DIR"

          # Keep upstream package.json/forge packagerConfig for MSIX to avoid
          # manifest executable-name mismatch during makeappx validation.

          node -e "
            const fs = require('fs');
            const path = require('path');
            const meta = require('./desktop/branding/metadata.json');
            const projectRoot = process.env.TMP_DIR;

            const productName = meta.productName || meta.appName || 'MCP Magic';
            const terminalProductName = meta.terminalProductName || productName.toUpperCase();
            const deepLinkScheme = (meta.deepLinkScheme || meta.appName || productName)
              .toLowerCase()
              .replace(/[^a-z0-9]/g, '');

            const replaceInFile = (relPath, replacements) => {
              const filePath = path.join(projectRoot, relPath);
              if (!fs.existsSync(filePath)) return;
              let content = fs.readFileSync(filePath, 'utf8');
              let changed = false;
              for (const [from, to] of replacements) {
                if (content.includes(from)) {
                  content = content.split(from).join(to);
                  changed = true;
                }
              }
              if (changed) fs.writeFileSync(filePath, content);
            };

            replaceInFile('index.html', [
              ['<title>Talk To Figma</title>', '<title>' + productName + '</title>'],
            ]);

            replaceInFile('src/App.tsx', [
              ['TalkToFigma Desktop v2.0.0', terminalProductName + ' Desktop v2.0.0'],
              ['talktofigma://', deepLinkScheme + '://'],
            ]);

            replaceInFile('src/components/app-sidebar.tsx', [
              ['alt=\"TalkToFigma\"', 'alt=\"' + productName + '\"'],
              ['>TalkToFigma</span>', '>' + productName + '</span>'],
            ]);

            replaceInFile('src/pages/Settings.tsx', [
              ['Configure TalkToFigma Desktop with your preferred MCP client', 'Configure ' + productName + ' with your preferred MCP client'],
            ]);

            replaceInFile('src/pages/Help.tsx', [
              ['Learn how to use TalkToFigma Desktop with our interactive tutorial', 'Learn how to use ' + productName + ' with our interactive tutorial'],
              ['Follow our step-by-step tutorial to get started with TalkToFigma Desktop.', 'Follow our step-by-step tutorial to get started with ' + productName + '.'],
            ]);
          "
          mkdir -p "$TMP_DIR/public"
          cp "$ROOT/desktop/branding/icon.ico" "$TMP_DIR/public/icon.ico"
          cp "$ROOT/desktop/branding/icon.png" "$TMP_DIR/public/icon.png"
          cp "$ROOT/desktop/branding/trayTemplate.png" "$TMP_DIR/public/trayTemplate.png"
          cp "$ROOT/desktop/branding/trayTemplate_active.png" "$TMP_DIR/public/trayTemplate_active.png"
          cp "$ROOT/desktop/branding/tray_dark.png" "$TMP_DIR/public/tray_dark.png"
          cp "$ROOT/desktop/branding/tray_dark_active.png" "$TMP_DIR/public/tray_dark_active.png"

          cd "$TMP_DIR"
          npm ci

          VERSION="${{ needs.resolve-version.outputs.windows_version }}"
          BUILD_VERSION="$VERSION"

          # Inject appVersion for Windows/MSIX (e.g. 2.0.9.20)
          node -e "
            const fs = require('fs');
            let c = fs.readFileSync('forge.config.ts', 'utf8');
            if (/appVersion:\s*'[^']*'/.test(c)) {
              c = c.replace(/appVersion:\s*'[^']*'/, \"appVersion: '${VERSION}'\");
            } else {
              c = c.replace(/packagerConfig:\s*{/, \"packagerConfig: {\\n    appVersion: '${VERSION}',\");
            }
            fs.writeFileSync('forge.config.ts', c);
          "

          export PLATFORM=msstore
          export APP_VERSION="$BUILD_VERSION"
          export CI=1
          export DEBUG=electron-forge:*,electron-windows-msix*
          mkdir -p "$ROOT/artifacts"

          npm run make -- --targets=msix --verbose 2>&1 | tee "$ROOT/artifacts/msix-make.log"

          echo "$VERSION" > "$ROOT/artifacts/release_version.txt"
          echo "$BUILD_VERSION" > "$ROOT/artifacts/build_version.txt"
          if [ -d "$TMP_DIR/out" ]; then
            cp -R "$TMP_DIR/out"/* "$ROOT/artifacts/"
          fi

          rm -rf "$TMP_DIR"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: msix-artifacts
          path: artifacts/**

      - name: Extract version
        id: version
        run: |
          echo "version=$(cat artifacts/release_version.txt | tr -d '\n')" >> $GITHUB_OUTPUT

  release:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: write
    needs:
      - build-mas
      - upload-mas
      - build-msix
    if: ${{ needs.build-mas.result == 'success' && needs.upload-mas.result == 'success' && needs.build-msix.result == 'success' }}
    steps:
      - name: Download MAS artifacts
        uses: actions/download-artifact@v4
        with:
          name: mas-artifacts
          path: artifacts/mas

      - name: Download MSIX artifacts
        uses: actions/download-artifact@v4
        with:
          name: msix-artifacts
          path: artifacts/msix

      - name: Resolve version
        id: version
        shell: bash
        run: |
          set -euo pipefail
          VERSION=""
          if [ -f artifacts/mas/release_version.txt ]; then
            VERSION="$(tr -d '\r\n' < artifacts/mas/release_version.txt)"
          fi
          if [ -z "$VERSION" ] && [ -f artifacts/msix/release_version.txt ]; then
            VERSION="$(tr -d '\r\n' < artifacts/msix/release_version.txt)"
          fi
          if [ -z "$VERSION" ]; then
            echo "::error::release_version.txt not found or empty"
            exit 1
          fi
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"

      - name: Prepare release assets
        shell: bash
        run: |
          set -euo pipefail
          VERSION="${{ steps.version.outputs.version }}"
          mkdir -p release-assets

          PKG_SRC="$(find artifacts/mas -type f -name '*-universal.pkg' | head -n1 || true)"
          if [ -z "$PKG_SRC" ]; then
            PKG_SRC="$(find artifacts/mas -type f -name '*.pkg' | head -n1 || true)"
          fi
          if [ -z "$PKG_SRC" ]; then
            echo "::error::No .pkg artifact found"
            exit 1
          fi

          MSIX_SRC="$(find artifacts/msix -type f -name '*.msix' | head -n1 || true)"
          if [ -z "$MSIX_SRC" ]; then
            echo "::error::No .msix artifact found"
            exit 1
          fi

          cp "$PKG_SRC" "release-assets/MCP.Magic-${VERSION}-universal.pkg"
          cp "$MSIX_SRC" "release-assets/MCP.Magic-${VERSION}.msix"

      - name: Upload release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.version.outputs.version }}
          files: |
            release-assets/*.pkg
            release-assets/*.msix
          fail_on_unmatched_files: false
